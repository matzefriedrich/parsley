package {{.PackageName}}

import ({{range $i, $path := .Imports}}
    "{{$path}}"
{{end}})
{{range $i, $interface := .Interfaces}}
type {{$interface.Name}}ProxyImpl struct {
    features.ProxyBase
    target {{$interface.Name}}
}

type {{$interface.Name}}Proxy interface {
    {{$interface.Name}}
}

func New{{$interface.Name}}ProxyImpl(target {{$interface.Name}}, interceptors []features.MethodInterceptor) {{$interface.Name}}Proxy {
    return &{{$interface.Name}}ProxyImpl{
        ProxyBase: features.NewProxyBase(target, interceptors),
        target:    target,
    }
}
{{end}}{{range
    $i, $interface := .Interfaces}}{{range $m, $method := .Methods}}
func (p *{{$interface.Name}}ProxyImpl) {{$method.Name}}({{$method.FormattedParameters}}) {{$method.FormattedResultTypes}} {

    const methodName = "{{$method.Name}}"
    parameters := map[string]interface{}{ {{range
        $p, $parameter := .Parameters}}
		"{{$parameter.Name}}": {{$parameter.Name}},
{{end}}	}

	callContext := features.NewMethodCallContext(methodName, parameters)
	p.InvokeEnterMethodInterceptors(callContext)
	defer func() {
	    p.InvokeExitMethodInterceptors(callContext)
	}()
    {{if $method.HasResults }}
    {{$method.FormattedResultParameters}} := p.target.{{$method.Name}}({{$method.FormattedCallParameters}})
    p.InvokeMethodErrorInterceptors(callContext, {{$method.FormattedResultParameters}})
    return {{$method.FormattedResultParameters}}{{else}}
    p.target.{{$method.Name}}({{$method.FormattedCallParameters}}){{end}}
}
{{end}}{{end}}
{{range
    $i, $interface := .Interfaces}}var _ {{$interface.Name}} = &{{$interface.Name}}ProxyImpl{}
{{end}}